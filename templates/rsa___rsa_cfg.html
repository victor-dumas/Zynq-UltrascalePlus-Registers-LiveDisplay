<!doctype html>
<html>
<head>
<title>rsa_cfg (RSA) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___rsa.html")>RSA Module</a> &gt; rsa_cfg (RSA) Register</p><h1>rsa_cfg (RSA) Register</h1>
<h2>rsa_cfg (RSA) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>rsa_cfg</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x0000000038</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FFCE0064 (RSA)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">rw<span class="tooltiptext">Normal read/write</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00000000</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>RSA Control</td></tr>
</table>
<p></p>
<h2>rsa_cfg (RSA) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>rd_endianness</td><td class="center"> 2</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>When cleared (0), the RD_DATA registers will not change the incoming APB byte ordering. When set (1), the incomming APB byte locations will be flipped before saving to the RAM. The byte flip is as follows:<br/>- Byte[3] -> Byte[0]<br/>- Byte[2] -> Byte[1]<br/>- Byte[1] -> Byte[2]<br/>- Byte[0] -> Byte[3]<br/>This is a static signal and should not be changed while data is being written or read to the RSA data registers.</td></tr>
<tr valign=top><td>wr_endianness</td><td class="center"> 1</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>When cleared (0), the WR_DATA registers will not change the incoming APB byte ordering. When set (1), the incomming APB byte locations will be flipped before saving to the RAM. The byte flip is as follows:<br/>- Byte[3] -> Byte[0]<br/>- Byte[2] -> Byte[1]<br/>- Byte[1] -> Byte[2]<br/>- Byte[0] -> Byte[3]<br/>This is a static signal and should not be changed while data is being written or read to the RSA data registers.</td></tr>
<tr valign=top><td>slverr_en</td><td class="center"> 0</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>By default, invalid address requests are ignored. However, a maskable interrupt exsists. By enabling this slverr_enable invalid address requests cause a slverr to occur.<br/>Enable/Disable SLVERR during address decode failure.<br/>0: SLVERR is disabled. For request address: Writes are ignored. Read returns 0.<br/>1: SLVERR is enabled. For requestes address, SLVERR is asserted. Writes are ignored. Read returns 0.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>