<!doctype html>
<html>
<head>
<title>DCTL (USB3_XHCI) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___usb3_xhci.html")>USB3_XHCI Module</a> &gt; DCTL (USB3_XHCI) Register</p><h1>DCTL (USB3_XHCI) Register</h1>
<h2>DCTL (USB3_XHCI) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>DCTL</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x000000C704</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FE20C704 (USB3_0_XHCI)<br/>0x00FE30C704 (USB3_1_XHCI)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">mixed<span class="tooltiptext">Mixed types. See bit-field details.</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00000000</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>Device Control Register<br/>Note:<br/>When Hibernation is not enabled using GCTL.GblHibernationEn field,<br/>- you can write any value to CSS, CRS, L1HibernationEn, and KeepConnect fields<br/>- L1HibernationEn, and KeepConnect fields always return 0 when read in this hibernation-disabled state</td></tr>
</table>
<p></p>
<h2>DCTL (USB3_XHCI) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>RUN_STOP</td><td class="center">31</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Run/Stop<br/>The software writes 1 to this bit to start the device controller operation.<br/>To stop the device controller operation, the software must remove any active transfers and write 0 to this bit. When the controller is stopped, it sets the DSTS.DevCtrlHlt bit when the core is idle and the lower layer finishes the disconnect process.<br/>The Run/Stop bit must be used in following cases as specified:<br/>- After power-on reset and CSR initialization, the software must write 1 to this bit to start the device controller. The controller does not signal connect to the host until this bit is set.<br/>- The software uses this bit to control the device controller to perform a soft disconnect. When the software writes 0 to this bit, the host does not see that the device is connected. The device controller stays in the disconnected state until the software writes 1 to this bit. The minimum duration of keeping this bit cleared is specified in the Note below. If the software attempts a connect after the soft disconnect or detects a disconnect event, it must set DCTL[8:5] to 5 before reasserting the Run/Stop bit.<br/>- When the USB or Link is in a lower power state and the Two Power Rails configuration is selected, software writes 0 to this bit to indicate that it is going to turn off the Core Power Rail. After the software turns on the Core Power Rail again and re-initializes the device controller, it must set this bit to start the device controller.<br/>Note: The following is the minimum duration under various conditions for which the soft disconnect (SftDiscon) bit must be set for the USB host to detect a device disconnect:<br/>30ms:<br/>- For SuperSpeed, when the device state is Suspended, Idle, Transmit, or Receive.<br/>10ms:<br/>- For high-speed, when the device state is Suspended, Idle, or not Idle/Suspended (performing transactions)<br/>- For full-speed/low-speed, when the device state is Suspended, Idle, or not Idle/Supended (performing transactions)<br/>To accommodate clock jitter, it is recommended that the application add extra delay to the specified minimum duration.</td></tr>
<tr valign=top><td>CSFTRST</td><td class="center">30</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Core Soft Reset<br/>Resets the all clock domains as follows:<br/>- This bit clears the interrupts and all the CSRs except GSTS, GSNPSID, GGPIO, GUID, GUSB2PHYCFGn registers, GUSB3PIPECTLn registers, DCFG, DCTL, DEVTEN, and DSTS registers.<br/>- All module state machines (except the SoC Bus Slave Unit) are reset to the IDLE state, and all the TxFIFOs and the RxFIFO are flushed.<br/>- Any transactions on the SoC bus Master are terminated as soon as possible, after gracefully completing the last data phase of a SoC bus transfer. Any transactions on the USB are terminated immediately.<br/>The application can write this bit at any time to reset the core. This is a self-clearing bit; the core clears this bit after all necessary logic is reset in the core, which may take several clocks depending on the core's current state. Once this bit is cleared, the software must wait at least 3 PHY clocks before accessing the PHY domain (synchronization delay). Typically, software reset is used during software development and also when you dynamically change the PHY selection bits in the USB configuration registers listed above. When you change the PHY, the corresponding clock for the PHY is selected and used in the PHY domain. Once a new clock is selected, the PHY domain must be reset for proper operation.<br/>Note: Programming this field with random data causes side effect. Bit Bash register testing is not recommended.</td></tr>
<tr valign=top><td class="grayback">Reserved</td><td class="grayback center">29</td><td class="tooltip grayback">ro<span class="tooltiptext">Read-only</span></td><td class="hex grayback">0x0</td><td class=grayback>Reserved1</td></tr>
<tr valign=top><td>HIRDTHRES</td><td class="center">28:24</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>HIRD Threshold (HIRD_Thres)<br/>The core asserts output signals utmi_l1_suspend_n and utmi_sleep_n on the basis of this signal:<br/>The core asserts utmi_l1_suspend_n to put the PHY into Deep Low-Power mode in L1 when both of the following are true:<br/>- HIRD value is greater than or equal to the value in DCTL.HIRD_Thres[3:0]<br/>- HIRD_Thres[4] is set to 1'b1.<br/>The core asserts utmi_sleep_n on L1 when one of the following is true:<br/>- If the HIRD value is less than HIRD_Thres[3:0] or<br/>- HIRD_Thres[4] is set to 1'b0.<br/>Note: This field must be set to '0' during SuperSpeed mode of operation.</td></tr>
<tr valign=top><td>LPM_NYET_thres</td><td class="center">23:20</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>LPM NYET Threshold<br/>When LPM Errata is enabled:<br/>Bits [23:20]: LPM NYET Response Threshold (LPM_NYET_thres)<br/>Handshake response to LPM token specified by device application. Response depends on DCFG.LPMCap.<br/>- DCFG.LPMCap is 1'b0 - The core always responds with Timeout (that is, no response).<br/>- DCFG.LPMCap is 1'b1 - The core responds with an ACK on successful LPM transaction, which requires that all of the following are satisfied:<br/>- There are no PID or CRC5 errors in both the EXT token and the LPM token (if not true, inactivity results in a timeout ERROR).<br/>- No data is pending in the Transmit FIFO and OUT endpoints not in flow controlled state (else NYET).<br/>- The BESL value in the LPM token is less than or equal to LPM_NYET_thres[3:0]</td></tr>
<tr valign=top><td>KeepConnect</td><td class="center">19</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>When '1', this bit enables the save and restore programming model by preventing the core from disconnecting from the host when DCTL.RunStop is set to '0'.<br/>It also enables the Hibernation Request Event to be generated when the link goes to U3 or L2.<br/>The device core disconnects from the host when DCTL.RunStop is set to '0'.<br/>This bit indicates whether to preserve this behavior ('0'), or if the core must not disconnect when RunStop is set to 0 ('1').<br/>This bit also prevents the LTSSM from automatically going to U0/L0 when the host requests resume from U3/L2.</td></tr>
<tr valign=top><td>L1HibernationEn</td><td class="center">18</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>When this bit is set along with KeepConnect, the device core generates a Hibernation Request Event if L1 is enabled and the HIRD value in the LPM token is larger than the threshold programmed in DCTL.HIRD_Thres.<br/>The core does not exit the LPM L1 state until software writes Recovery into the DCTL.ULStChngReq field.<br/>This prevents corner cases where the device is entering hibernation at the same time the host is attempting to exit L1.</td></tr>
<tr valign=top><td>CRS</td><td class="center">17</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Controller Restore State (CRS)<br/>This command is similar to the USBCMD.CRS bit in host mode and initiates the restore process. When software sets this bit to '1', the controller immediately sets DSTS.RSS to '1'. When the controller has finished the restore process, it sets DSTS.RSS to '0'.<br/>Note: When read, this field always returns '0'.</td></tr>
<tr valign=top><td>CSS</td><td class="center">16</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Controller Save State (CSS)<br/>This command is similar to the USBCMD.CSS bit in host mode and initiates the save process. When software sets this bit to '1', the controller immediately sets DSTS.SSS to '1'. When the controller has finished the save process, it sets DSTS.SSS to '0'.<br/>Note: When read, this field always returns '0'.</td></tr>
<tr valign=top><td class="grayback">Reserved</td><td class="grayback center">15:13</td><td class="tooltip grayback">ro<span class="tooltiptext">Read-only</span></td><td class="hex grayback">0x0</td><td class=grayback>Reserved</td></tr>
<tr valign=top><td>INITU2ENA</td><td class="center">12</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Initiate U2 Enable<br/>- 1'b0: May not initiate U2 (default)<br/>- 1'b1: May initiate U2<br/>On USB reset, hardware clears this bit to 0. Software sets this bit after receiving SetFeature(U2_ENABLE), and clears this bit when ClearFeature(U2_ENABLE) is received.<br/>If DCTL[11] (AcceptU2Ena) is 0, the link immediately exits U2 state.</td></tr>
<tr valign=top><td>ACCEPTU2ENA</td><td class="center">11</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Accept U2 Enable<br/>- 1'b0: Reject U2 except when Force_LinkPM_Accept bit is set (default)<br/>- 1'b1: Core accepts transition to U2 state if nothing is pending on the application side.<br/>On USB reset, hardware clears this bit to 0. Software sets this bit after receiving a SetConfiguration command.</td></tr>
<tr valign=top><td>INITU1ENA</td><td class="center">10</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Initiate U1 Enable<br/>- 1'b0: May not initiate U1 (default);<br/>- 1'b1: May initiate U1.<br/>On USB reset, hardware clears this bit to 0. Software sets this bit after receiving SetFeature(U1_ENABLE), and clears this bit when ClearFeature(U1_ENABLE) is received.<br/>If DCTL[9] (AcceptU1Ena) is 0, the link immediately exits U1 state.</td></tr>
<tr valign=top><td>ACCEPTU1ENA</td><td class="center"> 9</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Accept U1 Enable<br/>- 1'b0: Core rejects U1 except when Force_LinkPM_Accept bit is set (default)<br/>- 1'b1: Core accepts transition to U1 state if nothing is pending on the application side.<br/>On USB reset, hardware clears this bit to 0. Software sets this bit after receiving a SetConfiguration command.</td></tr>
<tr valign=top><td>ULSTCHNGREQ</td><td class="center"> 8:5</td><td class="tooltip">wo<span class="tooltiptext">Write-only</span></td><td class="hex">0</td><td>ULSTCHNGREQ<br/>Software writes this field to issue a USB/Link state change request. A change in this field indicates a new request to the core.<br/>If software wants to issue the same request back-to-back, it must write a 0 to this field between the two requests. The result of the state change request is reflected in the USB/Link State in DSTS. These bits are self-cleared on the MAC Layer exiting suspended state.<br/>If software is updating other fields of the DCTL register and not intending to force any link state change, then it must write a 0 to this field.<br/>SS Compliance mode is normally entered and controlled by the remote link partner. Refer to the USB 3.0 specification.<br/>Alternatively, you can force the local link directly into compliance mode, by resetting the SS link with the RUN/STOP bit set to zero.<br/>If you then write '10' to the USB/Link State Change field and '1' to RUN/STOP, the link goes to compliance mode.<br/>Once you are in compliance, you may alternately write zero and '10' to this field to advance the compliance pattern.<br/>In SS mode:<br/>- Value Requested Link State Transition/Action<br/>- 0<br/>No Action<br/>- 4<br/>SS.Disabled<br/>- 5<br/>Rx.Detect<br/>- 6<br/>SS.Inactive<br/>- 8<br/>Recovery<br/>- 10<br/>Compliance<br/>- Others:<br/>Reserved<br/>In HS/FS/LS mode:<br/>- ValueRequested USB state transition<br/>- 8<br/>Remote wakeup request<br/>- Others: Reserved<br/>The Remote wakeup request must be issued 2us after the device goes into suspend state (DSTS[21:18] is 3.<br/>Note: After coming out of hibernation, software must write 8 (Recovery) into this field to confirm exit from the suspended state.</td></tr>
<tr valign=top><td>TSTCTL</td><td class="center"> 4:1</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Test Control<br/>- 4'b000: Test mode disabled<br/>- 4'b001: Test_J mode<br/>- 4'b010: Test_K mode<br/>- 4'b011: Test_SE0_NAK mode<br/>- 4'b100: Test_Packet mode<br/>- 4'b101: Test_Force_Enable<br/>- Others: Reserved</td></tr>
<tr valign=top><td class="grayback">Reserved</td><td class="grayback center"> 0</td><td class="tooltip grayback">ro<span class="tooltiptext">Read-only</span></td><td class="hex grayback">0x0</td><td class=grayback>Reserved</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>