<!doctype html>
<html>
<head>
<title>GCTL (USB3_XHCI) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___usb3_xhci.html")>USB3_XHCI Module</a> &gt; GCTL (USB3_XHCI) Register</p><h1>GCTL (USB3_XHCI) Register</h1>
<h2>GCTL (USB3_XHCI) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>GCTL</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x000000C110</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FE20C110 (USB3_0_XHCI)<br/>0x00FE30C110 (USB3_1_XHCI)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">rw<span class="tooltiptext">Normal read/write</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00693004</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>Global Core Control Register<br/>Note:<br/>When Hibernation is not enabled, you can write any value to GblHibernationEn. It always returns 0 when read.</td></tr>
</table>
<p></p>
<h2>GCTL (USB3_XHCI) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>PWRDNSCALE</td><td class="center">31:19</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0xD</td><td>Power Down Scale (PwrDnScale)<br/>The USB3 suspend_clk input replaces pipe3_rx_pclk as a clock source to a small part of the USB3 core that operates when the SS PHY is in its lowest power (P3) state, and therefore does not provide a clock.<br/>The Power Down Scale field specifies how many suspend_clk periods fit into a 16 kHz clock period. When performing the division, round up the remainder.<br/>For example, when using an 8-bit/16-bit/32-bit PHY and 25-MHz Suspend clock,<br/>Power Down Scale = 25000 kHz/16 kHz = 13'd1563 (rounder up)<br/>Note:<br/>- Minimum Suspend clock frequency is 32 kHz<br/>- Maximum Suspend clock frequency is 125 MHz<br/>The LTSSM uses Suspend clock for 12-ms and 100-ms timers during suspend mode. According to the USB 3.0 specification, the accuracy on these timers is 0% to +50%.<br/>- 12 ms + 0~+50% accuracy = 18 ms (Range is 12 ms - 18 ms)<br/>- 100 ms + 0~+50% accuracy = 150 ms (Range is 100 ms - 150 ms).<br/>The suspend clock accuracy requirement is:<br/>- (12,000/62.5) * (GCTL[31:19]) * actual suspend_clk_period must be between 12,000 and 18,000<br/>- (100,0000/62.5) * (GCTL[31:19]) * actual suspend_clk_period must be between 100,000 and 150,000<br/>For example, if your suspend_clk frequency varies from 7.5 MHz to 10.5MHz, then the value needs to programmed is:<br/>Power Down Scale = 10500/16 = 657 (rounded up; and fastest frequency used).</td></tr>
<tr valign=top><td>MASTERFILTBYPASS</td><td class="center">18</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Master Filter Bypass<br/>When this bit is set to 1'b1, irrespective of the parameter `DWC_USB3_EN_BUS_FILTERS chosen, all the filters in the DWC_usb3_filter module are bypassed.<br/>The double synchronizers to mac_clk preceding the filters are also bypassed. For enabling the filters, this bit must be 1'b0.</td></tr>
<tr valign=top><td>BYPSSETADDR</td><td class="center">17</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Bypass SetAddress in Device Mode.<br/>When BYPSSETADDR bit is set, the device core uses the value in the DCFG[DevAddr] bits directly for comparing the device address in the tokens.<br/>For simulation, you can use this feature to avoid sending an actual SET ADDRESS control transfer on the USB, and make the device core respond to a new address.<br/>When the xHCI Debug capability is enabled and this bit is set, the Debug Target immediately enters the configured state without requiring the Debug Host to send a SetAddress or SetConfig request.<br/>Note: You can set this bit for simulation purposes only. In the actual hardware, this bit must be set to 1'b0.</td></tr>
<tr valign=top><td>U2RSTECN</td><td class="center">16</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x1</td><td>U2RSTECN<br/>If the SuperSpeed connection fails during POLL or LMP exchange, the device connects at non-SS mode.<br/>If this bit is set, then device attempts three more times to connect at SS, even if it previously failed to operate in SS mode. For each attempt, the device checks receiver termination eight times.<br/>From 2.60a release, this bit controls whether to check for Rx.Detect eight times or one time for every attempt. Device controller on USB 2.0 reset checks for receiver termination eight times per attempt if this bit is set to zero, or only once per attempt if the bit is set to one.<br/>Note: This bit is applicable only in device mode.</td></tr>
<tr valign=top><td>FRMSCLDWN</td><td class="center">15:14</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>FRMSCLDWN<br/>This field scales down device view of a SOF/USOF/ITP duration.<br/>For SS/HS mode:<br/>- Value of 2'h3 implements interval to be 15.625 us<br/>- Value of 2'h2 implements interval to be 31.25 us<br/>- Value of 2'h1 implements interval to be 62.5 us<br/>- Value of 2'h0 implements interval to be 125us<br/>For FS mode, the scale-down value is multiplied by 8.<br/>When xHCI Debug Capability is enabled, this field also scales down the MaxPacketSize of the IN and OUT bulk endpoint to allow more traffic during simulation. It can only be changed from a non-zero value during simulation.<br/>- 2'h0: 1024 bytes<br/>- 2'h1: 512 bytes<br/>- 2'h2: 256 bytes<br/>- 2'h3: 128 bytes</td></tr>
<tr valign=top><td>PRTCAPDIR</td><td class="center">13:12</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x3</td><td>PRTCAPDIR: Port Capability Direction (PrtCapDir)<br/>- 2'b01: for Host configurations<br/>- 2'b10: for Device configurations<br/>- 2'b11: for OTG configurations<br/>When DWC_USB3_EN_OTG is 0, then the core acts as a DRD. When DWC_USB3_EN_OTG is 1,<br/>- If PrtCapDir is 2'b11, it acts as an OTG 2.0 device with A-device or B-device determined by the IDDIG input, and Host or Peripheral role based on HNP.<br/>- If PrtCapDir is 2'b01, it acts as a DRD in host mode.<br/>- If PrtCapDir is 2'b10, it acts as a DRD in device mode. The OTG device can be programmed to enable/disable SRP and HNP by using the fields present in OCFG register.<br/>When DWC_USB3_EN_OTG is 2,<br/>- If PrtCapDir is 2'b11, it acts as an OTG 3.0 device with A-device or B-device determined by the IDDIG input, and Host or Peripheral role based on HNP/RSP.<br/>- If PrtCapDir is 2'b01, it acts as a DRD in host mode.<br/>- If PrtCapDir is 2'b10, it acts as a DRD in device mode. The OTG device can be programmed to enable/disable SRP and HNP/RSP using the fields present in the OCFG register.<br/>Note: For static Host-only/Device-only applications, use DRD Host or DRD Device mode. The combination of GCTL.PrtCapDir=2'b11 with SRP and HNP/RSP disabled is not recommended for these applications.<br/>The sequence for switching modes in DRD configuration is as follows:<br/>Switching from Device to Host:<br/>1. Reset the controller using GCTL[11] (CoreSoftReset).<br/>2. Set GCTL[13:12] (PrtCapDir) to 2'b01 (Host mode).<br/>3. Reset the host using USBCMD.HCRESET.<br/>4. Initialize the Host Registers<br/>Switching from Host to Device:<br/>1. Reset the controller using GCTL[11] (CoreSoftReset).<br/>2. Set GCTL[13:12] (PrtCapDir) to 2'b10 (Device mode).<br/>3. Reset the device by setting DCTL[30] (CSftRst).<br/>4. Register Initialization.<br/>Programming this field with random data causes the core to keep toggling between the host mode and the device mode. Bit Bash register testing is not recommended.</td></tr>
<tr valign=top><td>CORESOFTRESET</td><td class="center">11</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Core Soft Reset (CoreSoftReset)<br/>- 1'b0 - No soft reset<br/>- 1'b1 - Soft reset to core<br/>Clears the interrupts and all the CSRs except the following registers:<br/>- GCTL<br/>- GUCTL<br/>- GSTS<br/>- GSNPSID<br/>- GGPIO<br/>- GUID<br/>- GUSB2PHYCFGn registers<br/>- GUSB3PIPECTLn registers<br/>- DCFG<br/>- DCTL<br/>- DEVTEN<br/>- DSTS<br/>When you reset PHYs (using GUBS3PHYCFG or GUSB3PIPECTL registers), you must keep the core in reset state until PHY clocks are stable. This controls the bus, ram, and mac domain resets.<br/>Note: This bit is for debug purposes only. Use USBCMD.HCRESET in xHCI Mode and DCTL.SoftReset in device mode for soft reset.<br/>Programming this field with random data will reset the internal logic of the host controller. Due to this side effect Bit Bash register testing is not recommended.</td></tr>
<tr valign=top><td>SOFITPSYNC</td><td class="center">10</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>SOFITPSYNC<br/>If this bit is set to '0' operating in host mode, the core keeps the UTMI/ULPI PHY on the first port in a non-suspended state whenever there is a SuperSpeed port that is not in Rx.Detect, SS.Disable and U3.<br/>If this bit is set to '1' operating in host mode, the core keeps the UTMI/ULPI PHY on the first port in a non-suspended state whenever the other non-SuperSpeed ports are not in a suspended state. This feature is useful because it saves power by suspending UTMI/ULPI when SuperSpeed only is active, and it helps resolve when the PHY does not transmit a host resume unless it is placed in suspend state. This bit must be programmed as a part of initialization at power-on reset, and must not be dynamically changed afterwards.<br/>Note:<br/>- USB2PHYCFGn[6].PhySusp eventually decides to put the UTMI/ULPI PHY in to suspend state. In addition, when this bit is set to '1', the core generates ITP from the ref_clk based counter. Otherwise, ITP and SOF are generated from utmi/ulpi_clk[0] based counter. To program the reference clock period inside the core, refer to GUCTL[31:22].REFCLKPER.<br/>- This feature is valid in Host and DRD/OTG configurations and used only in Host mode operation.<br/>- If you never use this feature or the GFLADJ.GFLADJ_REFCLK_LPM_SEL, the minimum frequency for the ref_clk can be as low as 32KHz. You can connect the suspend_clk (as low as 32 KHz) to the ref_clk.<br/>- If you plan to enable hardware-based LPM or software-based LPM (PORTPMSC. HLE=1), then you cannot use this feature. Turn off this feature by setting this bit to '0' and use the GFLADJ.GFLADJ_REFCLK_LPM_SEL feature.<br/>- If you set this bit to '1', the GUSB2PHYCFG.U2_FREECLK_EXISTS bit and the DWC_USB3_FREECLK_USB2_EXIST parameter must be set to '0'.<br/>Program this bit to 0 if the core is intended to be operated in USB 3.0 mode.</td></tr>
<tr valign=top><td>U1U2TimerScale</td><td class="center"> 9</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Disable U1/U2 timer Scaledown (U1U2TimerScale).<br/>If set to '1' along with GCTL[5:4] (ScaleDown) = 2'bX1, disables the scale down of U1/U2 inactive timer values. This is for simulation mode only.</td></tr>
<tr valign=top><td>DEBUGATTACH</td><td class="center"> 8</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Debug Attach<br/>When this bit is set,<br/>- SS Link proceeds directly to the Polling link state (after RUN/STOP in the DCTL register is asserted) without checking remote termination;<br/>- Link LFPS polling timeout is infinite;<br/>- Polling timeout during TS1 is infinite (in case link is waiting for TXEQ to finish).</td></tr>
<tr valign=top><td>RAMCLKSEL</td><td class="center"> 7:6</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>RAM Clock Select (RAMClkSel)<br/>- 2'b00: bus clock<br/>- 2'b01: pipe clock (Only used in device mode)<br/>- 2'b10: In device mode , pipe/2 clock.In Host mode, controller switches ram_clk between pipe/2 clock, mac2_clk and bus_clk based on the status of the U2/U3 ports<br/>- 2'b11: In device mode, selects mac2_clk as ram_clk (when 8-bit UTMI or ULPI used. Not supported in 16-bit UTMI mode) In Host mode, controller switches ram_clk between pipe_clk, mac2_clk and bus_clk based on the status of the U2/U3 ports.<br/>In device mode, upon a USB reset and USB disconnect, the hardware clears these bits to 2'b00.<br/>Note:<br/>- In device mode, if you set RAMClkSel to 2'b11 (mac2_clk), the controller internally switches the ram_clk to bus_clk when the link state changes to Suspend (L2 or L3), and switches the ram_clk back to mac2_clk when the link state changes to resume or U2.<br/>- In host mode, if a value of 2/3 is chosen, then controller switches ram_clk between bus_clk, mac2_clk and pipe_clk, pipe_clk/2, based on the state of the U2/U3 ports. For example if only the U2 port is active and the U3 ports are suspended, then the ram_clk is swicthed to mac2_clk. When only the U3 ports are active and the U2 ports are suspended, then the core internally swicth the ram_clk to pipe3 clock and when all U2 and U3 ports are suspended, it switch the ram_clk to bus_clk. This allows de coupling the ram_clk from the bus_clk and depending on the bandwidth requiredmnet allows the bus_clk to be run at a lower frequency than the ram_clk requirements. bus_clk frequency still cannot go below 60Mhz in host mode, and this is not verified.<br/>A value of 2 can be chosen only if the pipe data width is 8 or 16 bits. In this case the when the ram_clk is switched to pipe_clk, it uses pipe_clk/2 instead of pipe_clk. If a value of 3 is chosen for RAMClkSel, then when ram_clk is switched to pipe_clk, then pipe_clk is used without any divider.<br/>- In device mode, when RAMClkSel != 2'b00, the bus_clk_early frequency can be a minimum of 1 MHz. This is tested in simulation and also in hardware with Linux, Microsoft Windows 8, and MCCI Windows7 host drivers. Only control and non periodic transfers are supported when bus_clk is 1 MHz. For periodic applications, the bus_clk_early minimum frequency is higher depending on your application and SoC bus. Even though 1 MHz has been tested with standard host drivers,<br/>recommends 5 MHz minimum for ASIC designs to provide a margin or at least have a backup option to increase the bus_clk frequency to 5 MHz if needed.<br/>Programming this field with random data will cause side effect. Bit Bash register testing is not recommended.</td></tr>
<tr valign=top><td>SCALEDOWN</td><td class="center"> 5:4</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Scale-Down Mode (ScaleDown)<br/>When Scale-Down mode is enabled for simulation, the core uses scaled-down timing values, resulting in faster simulations.<br/>When Scale-Down mode is disabled, actual timing values are used. This is required for hardware operation.<br/>HS/FS/LS Modes<br/>- 2'b00: Disables all scale-downs. Actual timing values are used.<br/>- 2'b01: Enables scale-down of all timing values except Device mode suspend and resume. These include Speed enumeration, HNP/SRP, and Host mode suspend and resume<br/>- 2'b10: Enables scale-down of Device mode suspend and resume timing values only.<br/>- 2'b11: Enables bit 0 and bit 1 scale-down timing values.<br/>SS Mode<br/>- 2'b00: Disables all scale-downs. Actual timing values are used.<br/>- 2'b01: Enables scaled down SS timing and repeat values including: (1) Number of TxEq training sequences reduce to 8; (2) LFPS polling burst time reduce to 256 nS; (3) LFPS warm reset receive reduce to 30 uS. Refer to the rtl_vip_scaledown_mapping.xls file under &lt;workspace>/sim/SoC_sim directory for the complete list.<br/>- 2'b10: No TxEq training sequences are sent. Overrides Bit 4.<br/>- 2'b11: Enables bit 0 and bit 1 scale-down timing values.</td></tr>
<tr valign=top><td>DISSCRAMBLE</td><td class="center"> 3</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Disable Scrambling (DisScramble)<br/>Transmit request to Link Partner on next transition to Recovery or Polling.</td></tr>
<tr valign=top><td>U2EXIT_LFPS</td><td class="center"> 2</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x1</td><td>U2EXIT_LFPS<br/>If this bit is,<br/>- 0: the link treats 248ns LFPS as a valid U2 exit.<br/>- 1: the link waits for 8us of LFPS before it detects a valid U2 exit.<br/>This bit is added to improve interoperability with a third party host controller. This host controller in U2 state while performing receiver detection generates an LFPS glitch of about 4ms duration. This causes the device to exit from U2 state because the LFPS filter value is 248ns. With the new functionality enabled, the device can stay in U2 while ignoring this glitch from the host controller.</td></tr>
<tr valign=top><td>GblHibernationEn</td><td class="center"> 1</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>GblHibernationEn<br/>This bit enables hibernation at the global level. If hibernation is not enabled through this bit, the PMU immediately accepts the D0->D3 and D3->D0 power state change requests, but does not save or restore any core state.<br/>In addition, the PMUs never drive the PHY interfaces and let the core continue to drive the PHY interfaces.</td></tr>
<tr valign=top><td>DSBLCLKGTNG</td><td class="center"> 0</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Disable Clock Gating (DsblClkGtng)<br/>This bit is set to 1 and the core is in Low Power mode, internal clock gating is disabled.<br/>You can set this bit to 1'b1 after Power On Reset.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>