<!doctype html>
<html>
<head>
<title>RFSHCTL3 (DDRC) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___ddrc.html")>DDRC Module</a> &gt; RFSHCTL3 (DDRC) Register</p><h1>RFSHCTL3 (DDRC) Register</h1>
<h2>RFSHCTL3 (DDRC) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>RFSHCTL3</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x0000000060</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FD070060 (DDRC)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">rw<span class="tooltiptext">Normal read/write</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00000000</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>Refresh Control Register 3</td></tr>
</table>
<p>All register fields are dynamic - refresh related, unless described otherwise in the register field description. Refresh related dynamic registers can be written at any time during operation, but to update them the following must be done: * Change the refresh associated register as desired. * After the changed register is known stable, toggle the RFSHCTL3.refresh_update_level signal.</p>
<h2>RFSHCTL3 (DDRC) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>refresh_mode</td><td class="center"> 6:4</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Fine Granularity Refresh Mode (DDR4 only)<br/>- 000 - Fixed 1x (Normal mode)<br/>- 001 - Fixed 2x<br/>- 010 - Fixed 4x<br/>- 101 - Enable on the fly 2x (not supported)<br/>- 110 - Enable on the fly 4x (not supported)<br/>- Everything else - reserved<br/>Note: The on-the-fly modes is not supported in this version of the DDRC.<br/>Note: Fine Granularity Refresh Mode is only supported in DDR4 mode.<br/>Note: This must be set up while the Controller is in reset or while the Controller is in self-refresh mode. Changing this during normal operation is not allowed.<br/>Programming Mode: Quasi-dynamic Group 2</td></tr>
<tr valign=top><td>refresh_update_level</td><td class="center"> 1</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Toggle this signal (either from 0 to 1 or from 1 to 0) to indicate that the refresh register(s) have been updated.<br/>The value is automatically updated when exiting reset, so it does not need to be toggled initially.</td></tr>
<tr valign=top><td>dis_auto_refresh</td><td class="center"> 0</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>When '1', disable auto-refresh generated by the DDRC. When auto-refresh is disabled, the SoC core must generate refreshes using the registers reg_ddrc_rank0_refresh and reg_ddrc_rank1_refresh.<br/>When dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately scheduled by the DDRC.<br/>If DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-refresh is not supported, and this bit must be set to '0'.<br/>This register field is changeable on the fly.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>