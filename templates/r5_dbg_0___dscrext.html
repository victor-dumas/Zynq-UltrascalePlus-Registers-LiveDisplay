<!doctype html>
<html>
<head>
<title>DSCRext (R5_DBG_0) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___r5_dbg_0.html")>R5_DBG_0 Module</a> &gt; DSCRext (R5_DBG_0) Register</p><h1>DSCRext (R5_DBG_0) Register</h1>
<h2>DSCRext (R5_DBG_0) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>DSCRext</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x0000000088</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FEBF0088 (CORESIGHT_R5_DBG_0)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">mixed<span class="tooltiptext">Mixed types. See bit-field details.</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00000002</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>Debug Status and Control Register</td></tr>
</table>
<p></p>
<h2>DSCRext (R5_DBG_0) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>RXfull</td><td class="center">30</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>The RXfull flag:<br/>0 = Read-DTR, DTRRX, empty.<br/>1 = Read-DTR, DTRRX, full.<br/>When set, this flag indicates to the processor that there is data available to read at the DTRRXint. It is automatically set on writes to the DTRRXext by the debugger, and is cleared when the processor reads the CP14 DTR. If the flag is not set, the DTRRXint returns an Unpredictable value.</td></tr>
<tr valign=top><td>TXfull</td><td class="center">29</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>The TXfull flag:<br/>0 = Write-DTR, DTRTX, empty.<br/>1 = Write-DTR, DTRTX, full.<br/>When clear, this flag indicates to the processor that the DTRTXint is ready to receive data. It is automatically cleared on reads ofthe DTRTXext by the debugger, and is set when the processor writes to the CP14 DTR. If this bit is set and the processor attempts to write to the DTRTXint, the register contents are overwritten and the TXfull flag remains set.</td></tr>
<tr valign=top><td>PipeAdv</td><td class="center">25</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Sticky pipeline advance read-only bit. This bit enables the debugger to detectwhether the processor is idle. In some situations, this might mean that the system bus port is deadlocked. This bit is set to 1 when the processor pipeline retires one instruction. It is cleared by a write to DRCR[3].<br/>0 = no instruction has completed execution since the last time this bit was cleared<br/>1 = an instruction has completed execution since the last time this bit was cleared</td></tr>
<tr valign=top><td>InstrCompl_l</td><td class="center">24</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Instruction complete read-only bit. Thisflag determines whether the processor has completed execution of an instruction issued through the APB port.<br/>0 = processor is executing an instruction fetched from the ITR Register<br/>1 = processor is not executing an instruction fetched from the ITR Register.<br/>When the APB port reads the DSCR and this bit is clear, then a subsequent write to the ITR Register is ignored unless DSCR[21:20] is not equal to 0. If DSCR[21:20] is not equal to 0, the ITR write stalls until the processor completes execution of the current instruction. If the processor is not in debug state, then the value read for this flag is Unpredictable. The flag is set to 1 on entry to debug state.</td></tr>
<tr valign=top><td>ExtDCCmode</td><td class="center">21:20</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>DTR access mode. You can use this field to optimize DTR traffic between a debugger and the processor.<br/>b00 = Non-blocking mode<br/>b01 = Stall mode<br/>b10 = Fast mode<br/>b11 = Reserved.<br/>Note<br/>. This field only affects the behavior ofDSCRext, DTRRXext, DTRTXext, and ITR accesses through the APB port, and not through CP14 debug instructions.<br/>. Non-blocking mode is the default setting. Improper use of the other modes might result in the debug access bus becoming deadlocked.</td></tr>
<tr valign=top><td>ADAdiscard</td><td class="center">19</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>The Asynchronous Aborts Discarded bit is set when the processor is in debug state and is cleared on exit from debug state. While this bit is set, the processor does not take asynchronous Data Aborts, instead, the sticky asynchronous Data Abort bit is set to 1.<br/>0 = do not discard asynchronous Data Aborts<br/>1 = discard asynchronous Data Aborts and set ADABORT_I.</td></tr>
<tr valign=top><td>NS</td><td class="center">18</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>reserved</td></tr>
<tr valign=top><td>SPNIDdis</td><td class="center">17</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This bit is the inverse of bit [6] of the AUTHSTATUS</td></tr>
<tr valign=top><td>SPIDdis</td><td class="center">16</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This bit is the inverse of bit [4] of the AUTHSTATUS</td></tr>
<tr valign=top><td>MDBGen</td><td class="center">15</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>The Monitor debug-mode enable bit:<br/>0 = Monitor debug-mode disabled<br/>1 = Monitor debug-mode enabled.<br/>If Halting debug-mode is enabled through bit [14], then the processor is in Halting debug-mode regardless of the value of bit [15]. If the external interface input DBGENm is LOW, this bit reads as 0. The programmed value is masked until DBGENm is HIGH, and at that time the read value reverts to the programmed value.</td></tr>
<tr valign=top><td>HDBGen</td><td class="center">14</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>The Halting debug-mode enable bit:<br/>0 = Halting debug-mode disabled<br/>1 = Halting debug-mode enabled.<br/>If the external interface input DBGENm is LOW, this bit reads as 0. The programmed value is masked until DBGENm is HIGH, and at that time the read value reverts to the programmed value.</td></tr>
<tr valign=top><td>ITRen</td><td class="center">13</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Execute Arm instruction enable bit:<br/>0 = disabled<br/>1 = enabled.<br/>If this bit is set and an ITR write succeeds, the processor fetches an instruction from the ITR for execution. If this bit is set to 1 when the processor is not in debug state, the behavior of the processor is Unpredictable.</td></tr>
<tr valign=top><td>UDCCdis</td><td class="center">12</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>CP14 debug user access disable control bit:<br/>0 = CP14 debug user access enable<br/>1 = CP14 debug user access disable.<br/>If this bit is set and a User mode process attemptsto access any CP14 debug registers, an Undefined Instruction exception is taken.</td></tr>
<tr valign=top><td>IntDis</td><td class="center">11</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Interrupts disable bit:<br/>0 = interrupts enabled<br/>1 = interrupts disabled.<br/>If this bit is set, the nIRQmand nFIQminput signals are inhibited. The external debugger can optionally use this bit to execute pieces of code in normal state aspart of the debugging process and avoid having an interrupt taking control of the program flow.</td></tr>
<tr valign=top><td>DbgAck</td><td class="center">10</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Force Debug Acknowledge bit. If this bit is set to 1, the DBGACKm output signal is forced HIGH, regardless of the processor state. The external debugger can optionally use this bit to execute pieces of code in normal state as part of the debugging process for the system to behave as if the processor is in debug state. Some systems rely on DBGACKm to determine whether data accesses are application or debugger generated.</td></tr>
<tr valign=top><td>UND_I</td><td class="center"> 8</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Sticky Undefined bit:<br/>0 = no Undefined Instruction exception occurred in debug state since the last time this bit was cleared<br/>1 = an Undefined Instruction exception occurred while in debug state since the last time this bit was cleared.<br/>This flag detects Undefined Instruction exceptions generated by instructions issued to the processor through the ITR. This bit is set to 1 when anUndefined Instruction exception occurs while the processor is in debug state and is cleared by writing a 1 to DRCR[2].</td></tr>
<tr valign=top><td>ADABORT_I</td><td class="center"> 7</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Sticky asynchronous Data Abort bit:<br/>0 = no asynchronous Data Aborts occurred since the last time this bit was cleared<br/>1 = an asynchronous Data Abort occurred since the last time this bit was cleared.<br/>This flag detects asynchronous DataAborts triggered by instructions issued to the processor through the ITR. This bit is set to 1 when an asynchronous Data Abort occurs while the processor is in debug state and is cleared by writing a 1 to DRCR[2].</td></tr>
<tr valign=top><td>SDABORT_I</td><td class="center"> 6</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Sticky synchronous Data Abort bit:<br/>0 = no synchronous Data Abort occurred since the last time this bit was cleared<br/>1 = a synchronous Data Abort occurred since the last time this bit was cleared.<br/>This flag detects synchronous DataAborts generated by instructionsissued to the processor through the ITR. This bit is set to 1 when a synchronous Data Abort occurs while the processor is in debug state and is cleared by writing to the DRCR[2].</td></tr>
<tr valign=top><td>MOE</td><td class="center"> 5:2</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>Method of entry bits:<br/>0000 = a DRCR[0] halting debug event occurred<br/>0001 = a breakpoint occurred<br/>0100 = an EDBGRQm halting debug event occurred<br/>0011 = a BKPT instruction occurred<br/>1010 = a synchronous watchpoint occurred others = reserved.<br/>These bits are set toindicate any of:<br/>. the cause of a debug exception<br/>. the cause for entering debug state.<br/>A Prefetch Abort or Data Abort handler must check the value of the CP15 Fault Status Register to determine whether a debug exception occurred and then use these bits to determine the specific debug event.</td></tr>
<tr valign=top><td>RESTARTED</td><td class="center"> 1</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x1</td><td>CPU restarted bit:<br/>0 = The processor is exiting debug state.<br/>1 = The processor has exited debug state.<br/>The debugger can poll this bit to determine when the processor responds to a request to leave debug state.</td></tr>
<tr valign=top><td>HALTED</td><td class="center"> 0</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>CPU halted bit:<br/>0 = The processor is in normal state.<br/>1 = The processor is in debug state.<br/>The debugger can poll this bit to determine when the processor has entered debug state.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>