<!doctype html>
<html>
<head>
<title>GUCTL1 (USB3_XHCI) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___usb3_xhci.html")>USB3_XHCI Module</a> &gt; GUCTL1 (USB3_XHCI) Register</p><h1>GUCTL1 (USB3_XHCI) Register</h1>
<h2>GUCTL1 (USB3_XHCI) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>GUCTL1</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x000000C11C</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FE20C11C (USB3_0_XHCI)<br/>0x00FE30C11C (USB3_1_XHCI)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">mixed<span class="tooltiptext">Mixed types. See bit-field details.</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00000000</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>Global User Control Register 1</td></tr>
</table>
<p></p>
<h2>GUCTL1 (USB3_XHCI) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td class="grayback">Reserved</td><td class="grayback center">31:30</td><td class="tooltip grayback">ro<span class="tooltiptext">Read-only</span></td><td class="hex grayback">0x0</td><td class=grayback>Reserved</td></tr>
<tr valign=top><td>FILTER_SE0_FSLS_EOP</td><td class="center">29</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>FILTER_SE0_FSLS_EOP<br/>- 0: Default behaviour, no change in Linestate check for SE0 detection in FS/LS<br/>- 1: Feature enabled, FS/LS SE0 is filtered for 2 clocks for detecting EOP<br/>This bit is applicable for FS/LS operation. If this feature is enabled, then SE0 on the linestate is validated for 2 consecutive utmi/ulpi clock edges for EOP detection. This feature is applicable only in FS in device mode and FS/LS mode of operation in host mode.<br/>- Device mode: FS -<br/>If GUCTL1.FILTER_SE0_FSLS_EOP is set, then for device LPM hanshake, the core will ignore single SE0 glitch on the linestate during transmit. Only 2 or more SE0 is considered as a valid EOP on FS.<br/>- Host mode: FS/LS - If GUCTL1.FILTER_SE0_FSLS_EOP is set, then the core will ignore single SE0 glitch on the linestate during transmit. Only 2 or more SE0 is considered as a valid EOP on FS/LS port.<br/>Enable this feature if the LineState has SE0 glitches during transmission. This bit is quasi-static, i.e., should not be changed during device operation.</td></tr>
<tr valign=top><td>TX_IPGAP_LINECHECK_DIS</td><td class="center">28</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>TX_IPGAP_LINECHECK_DIS<br/>- 0: Default behaviour, no change in Linestate check<br/>- 1: Feature enabled, 2.0 MAC disables Linestate check during HS transmit<br/>This bit is applicable for HS operation of u2mac. If this feature is enabled, then the 2.0 mac operating in HS ignores the UTMI/ULPI Linestate during the transmit of a token (during token-to-token and token-to-data IPGAP). When enabled, the controller implements a fixed 40-bit TxEndDelay after the packet is given on UTMI and ignores the Linestate during this time. This fetaure is applicable only in HS mode of operation.<br/>- Device mode: If GUCTL1.TX_IPGAP_LINECHECK_DIS is set, then for device LPM handshake, the core will ignore the linestate after TX and wait for a fixed clocks ( 40 bit times equivalent) after transmiting ACK on utmi.<br/>- Host mode:<br/>If GUCTL1.TX_IPGAP_LINECHECK_DIS is set, then the ipgap between (tkn to tkn/data) is added by 40 bit times of TXENDDELAY, and linestate is ignored during this 40 bit times delay.<br/>Enable this bit if the LineState will not reflect the expected line state (J) during transmission. This bit is quasi-static, i.e., should not be changed during device operation.</td></tr>
<tr valign=top><td>DEV_TRB_OUT_SPR_IND</td><td class="center">27</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>DEV_TRB_OUT_SPR_IND<br/>- 0: Default behaviour, no change in TRB status dword<br/>- 1: Feature enabled, OUT TRB status indicates Short Packet<br/>This bit is applicable for device mode only (and ignored in host mode). If the device application (SW/HW) wants to know if a short packet was received for an OUT in the TRB status itself, then this feature can be enabled, so that a bit is set in the TRB writeback in the buf_size dword. Bit[26] - SPR of the {trbstatus, RSVD, SPR, PCM1, bufsize} dword will be set during an OUT transfer TRB write back if this is the last TRB used for that transfer descriptor. This bit is quasi-static, i.e., should not be changed during device operation.</td></tr>
<tr valign=top><td>DEV_FORCE_20_CLK_FOR_30_CLK</td><td class="center">26</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>DEV_FORCE_20_CLK_FOR_30_CLK<br/>- 0: Default behaviour, Uses 3.0 clock when operating in 2.0 mode<br/>- 1: Feature enabled<br/>This bit is applicable (and to be set) for device mode (DCFG.Speed != SS) only. In the 3.0 device core, if the core is<br/>programmed to operate in 2.0 only (i.e., Device Speed is programmed to 2.0 speeds in DCFG[Speed]),<br/>then setting this bit makes the internal 2.0 (utmi/ulpi) clock to be routed as the 3.0 (pipe) clock. Enabling this feature allows the pipe3 clock to be not-running when forcibily operating in 2.0 device mode.<br/>Note: When using this feature, all pipe3 inputs must be in inactive mode, esp. pipe3 clocks not running and pipe3_phystatus_async must be tied to 0.<br/>This bit should not be set if the core is programmed to operate in SuperSpeed mode (even when it falls back to 2.0). This bit is quasi-static, i.e., should not be changed during operation.</td></tr>
<tr valign=top><td>P3_IN_U2</td><td class="center">25</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>P3_IN_U2<br/>- 0: Default behaviour, When SuperSpeed link is in U2 , PowerState P2 is attempted on the PIPE Interface.<br/>- 1: When SuperSpeed link is in U2, PowerState P3 is attempted if GUSB3PIPECTL[17] is set.<br/>Setting this bit enables P3 Power State when the SuperSpeed link is in U2. Another Power Saving option. Check with your PHY vendor before enabling this option.When setting this bit to 1 to enable P3 in P2, GUSB3PIPECTL[27] should be set to 0 to make sure that the U2 exit is attempted in P0. This bit should be set only when GCTL.SOFITPSYNC=1 or GFLADJ.GFLADJ_REFCLK_LPM_SEL=1.</td></tr>
<tr valign=top><td>DEV_L1_EXIT_BY_HW</td><td class="center">24</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>DEV_L1_EXIT_BY_HW<br/>- 0: Default behaviour, disables device L1 hardware exit logic<br/>- 1: feature enabled<br/>This bit is applicable for device mode (2.0) only. This field enables device controller sending remote wakeup for L1 if the device becomes ready for sending/accepting data when in L1 state.<br/>If the host expects the device to send remote wkp signalling to resume after going into L1 in flow controlled state, then this bit can be set to send the remote wake signal automatically when the device controller becomes ready.<br/>This HW remote wake feature is applicable only to bulk and interrupt transfers, and not for Isoch/Control<br/>- When control transfers are in progress, the LPM will be rejected (NYET response).<br/>Only after control transfers are completed (either with ACK/STALL), LPM will be accepted<br/>- For Isoch transfers, the host needs to do the wake-up<br/>and start the transfer. Device controller will not do remote-wakeup when Isoch endpoints get ready. The device SW needs to keep the GUSB2PHYCFG[EnblSlpM] reset in order to keep the PHY clock to be running for keeping track of SOF intervals.<br/>- When L1 hibernation is enabled, the controller will not do automatic exit for hibernation requests thru L1.<br/>This bit is quasi-static, i.e., should not be changed during device operation.</td></tr>
<tr valign=top><td>IP_GAP_ADD_ON</td><td class="center">23:21</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>This register<br/>field is used to add on to the default inter packet gap setting in the USB 2.0 MAC.<br/>This should be programmed to a non zero value only in case where you need to increase the<br/>default inter packet delay calculations in the USB 2.0 MAC module</td></tr>
<tr valign=top><td>DEV_LSP_TAIL_LOCK_DIS</td><td class="center">20</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>DEV_LSP_TAIL_LOCK_DIS<br/>- 0: Default behaviour, enables device lsp lock logic for tail TRB update<br/>- 1: Fix disabled<br/>This is a bug fix for STAR 9000716195 that affects the CSP mode for OUT endpoints in device mode. The issue is that tail TRB index is not synchronized with the cache Scratchpad bytecount update.<br/>If the fast-forward request comes in-between the bytecount update ona newly fetched TRB and the tail-index write update in TPF,<br/>the RDP works on an incorrect tail index and misses the byte count decrement for the newly fetched TRB in the fast-forwarding process.<br/>This fix needs to be present all the times.</td></tr>
<tr valign=top><td>NAK_PER_ENH_FS</td><td class="center">19</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>NAK_PER_ENH_FS<br/>- 1: Enables performance enhancement for FS async endpoints in the presence of NAKs<br/>- 0: Enhancement not applied<br/>If a periodic endpoint is present , and if a bulk endpoint which is also<br/>active is being NAKed by the device, then this could result in a<br/>decrease in performance of other Full Speed bulk endpoint which is ACked by the device.<br/>Setting this bit to 1, will enable the host controller to schedule more transactions<br/>to the async endpoints ( bulk/ control) and hence will improve the performance of the<br/>bulk endpoint.<br/>This control bit should be enabled only if the existing performance with the default<br/>setting is not sufficient for your FullSpeed application. Setting this bit will only<br/>control, and is only required for Full Speed transfers.</td></tr>
<tr valign=top><td>NAK_PER_ENH_HS</td><td class="center">18</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>NAK_PER_ENH_HS<br/>- 1: Enables performance enhancement for HS async endpoints in the presence of NAKs<br/>- 0: Enhancement not applied<br/>If a periodic endpoint is present , and if a bulk endpoint which is also<br/>active is being NAKed by the device, then this could result in a<br/>decrease in performance of other High Speed bulk endpoint which is ACked by the device.<br/>Setting this bit to 1, will enable the host controller to schedule more transactions<br/>to the async endpoints ( bulk/ control) and hence will improve the performance of the<br/>bulk endpoint.<br/>This control bit should be enabled only if the existing performance with the default<br/>setting is not sufficient for your HighSpeed application. Setting this bit will only<br/>control, and is only required for High Speed transfers.</td></tr>
<tr valign=top><td>PARKMODE_DISABLE_SS</td><td class="center">17</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>PARKMODE_DISABLE_SS<br/>This bit is used only in host mode, and is for debug purpose only.<br/>When this bit is set to '1' all SS bus instances in park mode are disabled.</td></tr>
<tr valign=top><td>PARKMODE_DISABLE_HS</td><td class="center">16</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>PARKMODE_DISABLE_HS<br/>This bit is used only in host mode.<br/>When this bit is set to '1' all HS bus instances park mode are disabled.<br/>To improve performance in park mode, the xHCI scheduler queues in three requests of 4 packets each for High Speed asynchronous endpoints in a micro-frame. But if a device is slow and if it NAKs more than 3 times, then it is rescheduled only in the next micro-frame. This could decrease the performance of a slow device even further.<br/>In a few high speed devices (such as Sandisk Cruzer Blade 4GB VID:1921, PID:21863 and Flex Drive VID:3744, PID:8552) when an IN request is sent within 900ns of the ACK of the previous packet, these devices send a NAK. When connected to these devices, if required, the software can disable the park mode if you see performance drop in your system. When park mode is disabled, pipelining of multiple packet is disabled and instead one packet at a time is requested by the scheduler. This allows up to 12 NAKs in a micro-frame and improves performance of these slow devices.</td></tr>
<tr valign=top><td>PARKMODE_DISABLE_FSLS</td><td class="center">15</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>PARKMODE_DISABLE_FSLS<br/>This bit is used only in host mode, and is for debug purpose only.<br/>When this bit is set to '1' all FS/LS bus instances in park mode disabled.</td></tr>
<tr valign=top><td class="grayback">Reserved</td><td class="grayback center">14:11</td><td class="tooltip grayback">ro<span class="tooltiptext">Read-only</span></td><td class="hex grayback">0x0</td><td class=grayback>Reserved</td></tr>
<tr valign=top><td>RESUME_TERMSEL_XCVRSEL_UNIFY</td><td class="center">10</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>When this bit is set to '0', termsel, xcvrsel will become 0 during end of resume while the opmode will become 0 once controller completes end of resume and enters U0 state (2 separate commandswill be issued). When this bit is set to '1', all the termsel, xcvrsel, opmode becomes 0 during end of resume itself (only 1 command will be issued)</td></tr>
<tr valign=top><td class="grayback">Reserved</td><td class="grayback center"> 9</td><td class="tooltip grayback">ro<span class="tooltiptext">Read-only</span></td><td class="hex grayback">0x0</td><td class=grayback>Reserved</td></tr>
<tr valign=top><td>L1_SUSP_THRLD_EN_FOR_HOST</td><td class="center"> 8</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>L1_SUSP_THRLD_EN_FOR_HOST<br/>This bit is used only in host mode.<br/>The host controller asserts the utmi_l1_suspend_n and utmi_sleep_n output signals as follows:<br/>The controller asserts the utmi_l1_suspend_n signal to put the PHY into deep low-power mode in L1 when both of the following are true:<br/>- The HIRD/BESL value used is greater than or equal to the value in L1_SUSP_THRLD_FOR_HOST field.<br/>- The L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1'b1.<br/>The controller asserts utmi_sleep_n on L1 when one of the following is true:<br/>- The HIRD/BESL value used is less than the value in L1_SUSP_THRLD_FOR_HOST field.<br/>- The L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1'b0.</td></tr>
<tr valign=top><td>L1_SUSP_THRLD_FOR_HOST</td><td class="center"> 7:4</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>L1_SUSP_THRLD_FOR_HOST<br/>This field is effective only when the L1_SUSP_THRLD_EN_FOR_HOST bit is set to 1. For more details, refer to the description of the L1_SUSP_THRLD_EN_FOR_HOST bit.</td></tr>
<tr valign=top><td>HC_ERRATA_ENABLE</td><td class="center"> 3</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Host ELD Enable (HELDEn)<br/>When this bit is set to 1, it enables the Exit Latency Delta (ELD) support defined in the xHCI 1.0 Errata.<br/>This bit is used only in the host mode. This bit has to be set to 1 in Host mode.</td></tr>
<tr valign=top><td>HC_PARCHK_DISABLE</td><td class="center"> 2</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Host Parameter Check Disable (HParChkDisable)<br/>When this bit is set to '0' (by default), the xHC checks that the input slot/EP context fields comply to the xHCI Specification. Upon detection of a parameter error during command execution, the xHC generates an event TRB with completion code indicating 'PARAMETER ERROR'.<br/>When the bit is set to '1', the xHC does not perform parameter checks and does not generate 'PARAMETER ERROR' completion code.</td></tr>
<tr valign=top><td>OVRLD_L1_SUSP_COM</td><td class="center"> 1</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>OVRLD_L1_SUSP_COM<br/>If this bit is set, the utmi_l1_suspend_com_n is overloaded with the utmi_sleep_n signal. This bit is usually set if the PHY stops the port clock during L1 sleep condition.<br/>Note: The recommended connection for the SUSPENDM/SLEEPM signals to the PHY with respect to this bit is as follows.<br/>For non-zero ports:<br/>Connect:<br/>- utmi_sleep_n[n] to SLEEPM[n]<br/>- (utmi_suspend_n[n] & utmi_l1_suspend_n[n]) to SUSPENDM[n]<br/>- USB2 PHYCLK[n] to utmi_clk[n]<br/>GUCTL1.OVRLD_L1_SUSP_COM impacts only Port0.<br/>For Port0:<br/>For<br/>PHY,<br/>GUSB2PHYCFGn.U2_FREECLK_EXISTS=1; With this connection, the PHY keeps PLL active so that FREECLK is always available irrespective of suspend/sleep.<br/>- Connect USB2 PHY COMMONONN to 0.<br/>- Connect utmi_sleep_n[0] to SLEEPM[0].<br/>- Connect (utmi_suspend_n[0] & utmi_l1_suspend_n[0]) to SUSPENDM[0].<br/>- Connect USB2 PHY FREECLK to utmi_clk[0].<br/>- Leave utmi_suspend_com_n, utmi_l1_suspend_com_n unconnected.<br/>- GUCTL1.OVRLD_L1_SUSP_COM can be set to any value.<br/>For Third Party PHY,<br/>GUSB2PHYCFGn.U2_FREECLK_EXISTS=0; With this connection the PHY can shut off all the clocks when the required conditions are met (like, GUSB2PHYCFGn[8,6], GUCTL1[1], GFLADJ[23], GCTL[10], Suspend condition, HW LPM enable etc).<br/>- Connect -utmi_suspend_com_n to SUSPENDM[0] (or equivalent).<br/>- Connect -utmi_l1_suspend_com_n to SLEEPM[0] (or equivalent).<br/>- Connect PHYCLK0 (first port clock) to utmi_clk[0].<br/>- Leave utmi_suspend_n[0], utmi_l1_suspend_ n[0], utmi_sleep_n[0] unconnected.<br/>- Set GUCTL1.OVRLD_L1_SUSP_COM to 1'b1.</td></tr>
<tr valign=top><td>LOA_FILTER_EN</td><td class="center"> 0</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>LOA_FILTER_EN<br/>If this bit is set, the USB 2.0 port babble is checked at least three consecutive times before the port is disabled. This prevents false triggering of the babble condition when using low quality cables.<br/>Note: This bit is valid only in host mode.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>