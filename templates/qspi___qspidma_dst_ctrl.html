<!doctype html>
<html>
<head>
<title>QSPIDMA_DST_CTRL (QSPI) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___qspi.html")>QSPI Module</a> &gt; QSPIDMA_DST_CTRL (QSPI) Register</p><h1>QSPIDMA_DST_CTRL (QSPI) Register</h1>
<h2>QSPIDMA_DST_CTRL (QSPI) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>QSPIDMA_DST_CTRL</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x000000080C</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FF0F080C (QSPI)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">rw<span class="tooltiptext">Normal read/write</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x803FFA00</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>General DST DMA Control</td></tr>
</table>
<p></p>
<h2>QSPIDMA_DST_CTRL (QSPI) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>FIFO_LVL_HIT_THRESH</td><td class="center">31:25</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x40</td><td>When the DST FIFO level is greater than or equal to this programmed value, the QSPI interface signal, "data_out_fifo_level_hit" will be asserted.<br/>7'h00: Reserved<br/>etc<br/>7'h0F: Reserved<br/>7'h10: Threshold is 17 entries<br/>etc<br/>7'h7A: Threshold is 123 entries<br/>7'h7B: Reserved<br/>etc<br/>7'h7F: Reserved<br/>Note that "7'h10" is the minimum and "7'h7A" is the max value that should be programmed<br/>This is a static signal - should not be changed while block is actively processing commands</td></tr>
<tr valign=top><td>APB_ERR_RESP</td><td class="center">24</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>When an APB (register) access occurs to an unimplemented space (there is no register at that location), the resulting pslverr will be:<br/>0: pslverr = 1'b0<br/>1: pslverr = 1'b1<br/>There is also a maskable interrupt , "INVALID_APB" that could be asserted, independent of what option is selected here.</td></tr>
<tr valign=top><td>ENDIANNESS</td><td class="center">23</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>When cleared (0), the DST_DMA will not change the outgoing AXI byte ordering<br/>When set (1), the DST_DMA will flip the outgoing AXI byte locations before sending to the AXI interface as follows:<br/>- Byte[3] -> Byte[0]<br/>- Byte[2] -> Byte[1]<br/>- Byte[1] -> Byte[2]<br/>- Byte[0] -> Byte[3]<br/>This is a static signal - should not be changed while block is actively processing commands</td></tr>
<tr valign=top><td>AXI_BRST_TYPE</td><td class="center">22</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>When cleared (0), the DST_DMA will issue INCR type bursts to memory<br/>When set (1), the DST_DMA will issue AXI FIXED type bursts to memory<br/>Note: Change this value only when controller is not processing commands.</td></tr>
<tr valign=top><td>TIMEOUT_VAL</td><td class="center">21:10</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0xFFE</td><td>Set the timeout value for SRC DMA. There are 2 physical timers, qualified with TIMEOUT_EN, that will compare against this value:<br/>1. Timeout counter starts to run when data is provided to the AXI write channel (memory) interface and backpressure is observed.<br/>As soon as backpressure is removed, the timer is reset. When timer expires, it stops running.<br/>2. Timeout counter runs whenever the DMA is active.<br/>Whenever a data beat is provided by the SSS, the timer is reset. When timer expires, it stops running.<br/>TIMEOUT_VAL field is interpreted as follows:<br/>Final timeout value = TIMEOUT_VAL * timeout_prescale_period<br/>where "timeout_prescale_period" is the period of the enable that is generated by the TIMEOUT_PRE.<br/>Examples (prescaler set to maximum of 4096 clk (~2.5ns) cycles)<br/>12'h000: Final Timeout after 1 * (4096 * 2.5ns)] => 10.244 us<br/>12'h001: Final Timeout after 2 * (4096 * 2.5ns)] => 20.48 us<br/>etc<br/>12'hFFF: Final Timeout after 4096 * (4096 * 2.5ns)] => 41.94 ms<br/>Note that if PAUSE_MEM is asserted, timeout counter #1 will be paused and if PAUSE_STRM is asserted, timeout counter #2 will be paused.<br/>When either of the 2 timers expire, this register requires an explicit write of 12'hFFF to clear them - both will be cleared.<br/>Note: Change this value only when controller is not processing commands.</td></tr>
<tr valign=top><td>FIFO_THRESH</td><td class="center"> 9:2</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x80</td><td>DST_FIFO programmed watermark value. This is the FIFO threshold used to trigger the FIFO_THRESHOLD_HIT interrupt.<br/>8'h00: Threshold is 0 entries<br/>8'h01: Threshold is 1 entry<br/>etc<br/>8'h80: Threshold is 128 entries<br/>Note that the interrupt will be triggered when the FIFO hits this threshold, irrespective of whether it is on the way up or down.<br/>Note: Change this value only when controller is not processing commands.</td></tr>
<tr valign=top><td>PAUSE_STRM</td><td class="center"> 1</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>1: Temporarily stop the transfer of data to the internal DST data FIFO from the stream interface. This in effect will lead to the emptying of the DST FIFO.<br/>0: DMA operates as usual. If previously PAUSED, it will continue on where it left off.<br/>Note. H/W has no means to apply backpressure to the stream interface. If PAUSE_STRM is asserted, the DMA will drop the stream data. This makes PAUSE mode functionally equivalent to as if the fifo were full. The value of PAUSE_STRM may therefore be limited to debug/verification only.</td></tr>
<tr valign=top><td>PAUSE_MEM</td><td class="center"> 0</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0x0</td><td>1: Temporarily stop the issuing of new write commands to memory. This in effect will eventually lead to the filling of the DST FIFO. Write memory commands that are already outstanding will continue to be processed, but no new write commands will be issued to memory while PAUSE_MEM is asserted.<br/>0: DMA operates as usual. If previously PAUSED, it will continue on where it left off.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>