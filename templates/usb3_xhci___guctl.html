<!doctype html>
<html>
<head>
<title>GUCTL (USB3_XHCI) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___usb3_xhci.html")>USB3_XHCI Module</a> &gt; GUCTL (USB3_XHCI) Register</p><h1>GUCTL (USB3_XHCI) Register</h1>
<h2>GUCTL (USB3_XHCI) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>GUCTL</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x000000C12C</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FE20C12C (USB3_0_XHCI)<br/>0x00FE30C12C (USB3_1_XHCI)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">mixed<span class="tooltiptext">Mixed types. See bit-field details.</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00000000</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>Global User Control Register:<br/>This register provides a few options for the software to control the core behavior in the Host mode. Most of the options are used to improve host inter-operability with different devices.</td></tr>
</table>
<p></p>
<h2>GUCTL (USB3_XHCI) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>REFCLKPER</td><td class="center">31:22</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>REFCLKPER<br/>This field indicates in terms of nano seconds the period of ref_clk. The default value of this register is set to 'h8 (8ns/125 MHz).<br/>This field needs to be updated during power-on initialization, if GCTL.SOFITPSYNC or GFLADJ.GFLADJ_REFCLK_LPM_SEL is set to '1'. The programmable maximum value is 62ns, and the minimum value is 8ns.<br/>You must use a reference clock with a period that is an integer multiple, so that ITP can meet the jitter margin of 32ns. The allowable ref_clk frequencies whose period is not integer multiples are 16/17/19.2/24/39.7MHz.<br/>This field must not be set to '0' at any time. If you never plan to use this feature, then set this field to 'h8, the default value.</td></tr>
<tr valign=top><td>NoExtrDl</td><td class="center">21</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>No Extra Delay Between SOF and the First Packet(NoExtrDl)<br/>Some HS devices misbehave when the host sends a packet immediately after a SOF. However, adding an extra delay between a SOF and the first packet can reduce the USB data rate and performance.<br/>This bit is used to control whether the host must wait for 2 microseconds before it sends the first packet after a SOF, or not. User can set this bit to one to improve the performance if those problematic devices are not a concern in the user's host environment.<br/>- 1'b0: Host waits for 2 microseconds after a SOF before it sends the first USB packet.<br/>- 1'b1: Host doesn't wait after a SOF before it sends the first USB packet.</td></tr>
<tr valign=top><td class="grayback">Reserved</td><td class="grayback center">20:18</td><td class="tooltip grayback">ro<span class="tooltiptext">Read-only</span></td><td class="hex grayback">0x0</td><td class=grayback>Reserved</td></tr>
<tr valign=top><td>SprsCtrlTransEn</td><td class="center">17</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Sparse Control Transaction Enable<br/>Some devices are slow in responding to Control transfers. Scheduling multiple transactions in one microframe/frame can cause these devices to misbehave.<br/>If this bit is set to 1'b1, the host controller schedules transactions for a Control transfer in different microframes/frames.</td></tr>
<tr valign=top><td>ResBwHSEPS</td><td class="center">16</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Reserving 85% Bandwidth for HS Periodic EPs (ResBwHSEPS)<br/>By default, HC reserves 80% of the bandwidth for periodic EPs. If this bit is set, the bandwidth is relaxed to 85% to accommodate two high speed, high bandwidth ISOC EPs.<br/>USB 2.0 required 80% bandwidth allocated for ISOC traffic. If two High-bandwidth ISOC devices (HD Webcams) are connected, and if each requires 1024-bytes X 3 packets per Micro-Frame, then the bandwidth required is around 82%. If this bit is set, then it is possible to connect two Webcams of 1024bytes X 3 paylod per Micro-Frame each. Otherwise, you may have to reduce the resolution of the Webcams.<br/>This bit is valid in Host and DRD configuration and is used in host mode operation only. Ignore this bit in device mode.</td></tr>
<tr valign=top><td>CMdevAddr</td><td class="center">15</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Compliance Mode for Device Address (CMdevAddr)<br/>When this bit is 1'b1, Slot ID may have different value than Device Address if max_slot_enabled &lt; 128.<br/>- 1'b1: Increment Device Address on each Address Device command.<br/>- 1'b0: Device Address is equal to Slot ID.<br/>The xHCI compliance requires this bit to be set to '1'. The '0' mode is for debug purpose only. This allows you to easily identify a device connected to a port in the Lecroy or Eliisys trace during hardware debug.<br/>This bit is valid in Host and DRD configuration and is used in host mode operation only. Ignore this bit in device mode.</td></tr>
<tr valign=top><td>USBHstInAutoRetryEn</td><td class="center">14</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Host IN Auto Retry (USBHstInAutoRetryEn)<br/>When set, this field enables the Auto Retry feature. For IN transfers (non-isochronous) that encounter data packets with CRC errors or internal overrun scenarios, the auto retry feature causes the Host core to reply to the device with a non-terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP != 0).<br/>If the Auto Retry feature is disabled (default), the core will respond with a terminating retry ACK (that is, an ACK transaction packet with Retry = 1 and NumP = 0).<br/>- 1'b0: Auto Retry Disabled<br/>- 1'b1: Auto Retry Enabled<br/>Note: This bit is also applicable to the device mode.</td></tr>
<tr valign=top><td>EnOverlapChk</td><td class="center">13</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Enable Check for LFPS Overlap During Remote Ux Exit:<br/>If this bit is set to,<br/>- 1'b1: The SuperSpeed link when exiting U1/U2/U3 waits for either the remote link LFPS or TS1/TS2 training symbols before it confirms that the LFPS handshake is complete. This is done to handle the case where the LFPS glitch causes the link to start exiting from the low power state. Looking for the LFPS overlap makes sure that the link partner also sees the LFPS.<br/>- 1'b0: When the link exists U1/U2/U3 because of a remote exit, it does not look for an LFPS overlap.</td></tr>
<tr valign=top><td>ExtCapSupptEN</td><td class="center">12</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>External Extended Capability Support Enable (ExtCapSuptEN)<br/>When set, this field enables extended capabilities to be implemented outside the core.<br/>When the ExtCapSupEN is set and the Debug Capability is enabled, the Next Capability pointer in 'Debug Capability' returns 16.<br/>A read to the first DWORD of the last internal extended capability (the 'xHCI Supported Protocol Capability for USB 3.0' when the Debug Capability is not enabled) returns a value of 4 in the Next Capability Pointer field.<br/>This indicates to software that there is another capability four DWORDs after this capability (for example, at address N+16 where N is the address of this DWORD).<br/>If enabled, an external address decoder that snoops the xHC slave interface must be implemented.<br/>If it sees an access to N+16 or greater, the slave access is re-routed to a piece of hardware which returns the external capability pointer register of the new capability and also handles reads/writes to this new capability and the side effects.<br/>If disabled, a read to the first DWORD of the last internal extended capability returns 0 in the 'Next Capability Pointer field. This indicates there are no more capabilities.</td></tr>
<tr valign=top><td>InsrtExtrFSBODI</td><td class="center">11</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Insert Extra Delay Between FS Bulk OUT Transactions (InsrtExtrFSBODl).<br/>Some FS devices are slow to receive Bulk OUT data and can get stuck when there are consecutive Bulk OUT transactions with short inter-transaction delays. This bit is used to control whether the host inserts extra delay between consecutive Bulk OUT transactions to a FS Endpoint.<br/>- 1'b0: Host doesn't insert extra delay between consecutive Bulk OUT transactions to a FS Endpoint.<br/>- 1'b1: Host inserts about 12us extra delay between consecutive Bulk OUT transactions to a FS Endpoint to work around the device issue.<br/>Note: Setting this bit to one will reduce the Bulk OUT transfer performance for most of the FS devices.</td></tr>
<tr valign=top><td>DTCT</td><td class="center">10:9</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Device Timeout Coarse Tuning (DTCT)<br/>This field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.<br/>The core first checks the DTCT value. If it is 0, then the timeout value is defined by the DTFT. If it is non-zero, then it uses the following timeout values:<br/>- 2'b00: 0 usec -> use DTFT value instead<br/>- 2'b01: 500 usec<br/>- 2'b10: 1.5 msec<br/>- 2'b11: 6.5 msec</td></tr>
<tr valign=top><td>DTFT</td><td class="center"> 8:0</td><td class="tooltip">rw<span class="tooltiptext">Normal read/write</span></td><td class="hex">0</td><td>Device Timeout Fine Tuning (DTFT)<br/>This field is a Host mode parameter which determines how long the host waits for a response from device before considering a timeout.<br/>For the DTFT field to take effect, DTCT must be set to 2'b00.<br/>The DTFT value is the number of 125 MHz clocks * 256 to count before considering a device timeout.<br/>The minimum value of DTFT is 2.<br/>For example, if the mac3_clk is 125 MHz clk (8 ns period), this is calculated as follows:<br/>(DTFT value) * 256 * (8 ns)<br/>Quick Reference:<br/>- if DTFT = 0x2, 2*256*8 = 4usec timeout<br/>- if DTFT = 0x5, 5*256*8 = 10usec timeout<br/>- if DTFT = 0xA, 10*256*8 = 20usec timeout<br/>- if DTFT = 0x10, 16*256*8 = 32usec timeout<br/>- if DTFT = 0x19, 25*256*8 = 51usec timeout<br/>- if DTFT = 0x31, 49*256*8 = 100usec timeout<br/>- if DTFT = 0x62, 98*256*8 = 200usec timeout<br/>Note: When SSIC is enabled, in HS_G1_G2_G3 mode when ssic_soc_pa_clk_freq = 2'b01, then DTFT value must be calculated for 156.25 MHz clock, for example, for equivalent delay of 32usec DTFT value must be 9'h14.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>