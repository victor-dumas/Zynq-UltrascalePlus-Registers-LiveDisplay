<!doctype html>
<html>
<head>
<title>reg_presentstate (SDIO) Register</title>
<meta name="robots" content="noindex, nofollow" />
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='css/_register_reference.css')}}">
<script src="xilfunctions.js" type="text/javascript"></script>
</head>
<body>
<p class=header><a href=# onclick=gotoTopic("_overview.html")>Zynq UltraScale+ Devices Register Reference</a> &gt; <a href=# onclick=gotoTopic("_module_summary.html")>Module Summary</a> &gt; <a href=# onclick=gotoTopic("mod___sdio.html")>SDIO Module</a> &gt; reg_presentstate (SDIO) Register</p><h1>reg_presentstate (SDIO) Register</h1>
<h2>reg_presentstate (SDIO) Register Description</h2>
<table class=noborder>
<tr valign=top><th width=20% class=sumparam>Register Name</th><td width=80% class=noborder>reg_presentstate</td></tr>
<tr valign=top><th class=sumparam>Relative Address</th><td class=noborder id="registerOffset">0x0000000024</td></tr>
<tr valign=top><th class=sumparam>Absolute Address</th><td class=noborder>
0x00FF160024 (SD0)<br/>0x00FF170024 (SD1)
</td></tr>
<tr valign=top><th class=sumparam>Width</th><td class=noborder>32</td></tr>
<tr valign=top><th class=sumparam>Type</th><td class="tooltip2 noborder">ro<span class="tooltiptext">Read-only</span></td></tr>
<tr valign=top><th class=sumparam>Reset Value</th><td class=noborder>0x00080000</td></tr>
<tr valign=top><th class=sumparam>Description</th><td class=noborder>SDIO Controller Status, read-only.</td></tr>
</table>
<p></p>
<h2>reg_presentstate (SDIO) Register Bit-Field Summary</h2>
<table>
<tr valign=top><th width=20%>Field Name</th><th width=10%>Bits</th><th width=10%>Type</th><th width=10%>Reset Value</th><th width=50%>Description</th></tr>
<tr valign=top><td>sdif_dat7in_dsync</td><td class="center">28</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging.</td></tr>
<tr valign=top><td>sdif_dat6in_dsync</td><td class="center">27</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging.</td></tr>
<tr valign=top><td>sdif_dat5in_dsync</td><td class="center">26</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging.</td></tr>
<tr valign=top><td>sdif_dat4in_dsync</td><td class="center">25</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging.</td></tr>
<tr valign=top><td>sdif_cmdin_dsync</td><td class="center">24</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging.</td></tr>
<tr valign=top><td>sdif_dat3in_dsync</td><td class="center">23</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging. This is<br/>especially useful in detecting the busy signal level from DAT[0].</td></tr>
<tr valign=top><td>sdif_dat2in_dsync</td><td class="center">22</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging. This is<br/>especially useful in detecting the busy signal level from DAT[0].</td></tr>
<tr valign=top><td>sdif_dat1in_dsync</td><td class="center">21</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging. This is<br/>especially useful in detecting the busy signal level from DAT[0].</td></tr>
<tr valign=top><td>sdif_dat0in_dsync</td><td class="center">20</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used to check DAT line level to recover from errors, and for debugging. This is<br/>especially useful in detecting the busy signal level from DAT[0].</td></tr>
<tr valign=top><td>sdif_wp_dsync</td><td class="center">19</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x1</td><td>The Write Protect Switch is supported for memory and combo cards.This bit reflects the inversion of the SDx_WP pin.<br/>0: Write protected, SDx_WP pin = High.<br/>1:<br/>Write enabled, SDx_WP pin = Low.</td></tr>
<tr valign=top><td>sdif_cd_n_dsync</td><td class="center">18</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This bit reflects the inverse value of the SDCD# pin.<br/>0: No Card present, SDx_CDn pin = High.<br/>1: Card present, SDx_CDn pin = Low.</td></tr>
<tr valign=top><td>sdhccarddet_statestable_dsync</td><td class="center">17</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This bit is used for testing. If it is 0, the Card Detect Pin Level is not stable. If this bit is set to 1,it means the Card Detect Pin Level is stable. The Software Reset For All in the Software Reset Register shall not affect this bit.'0' Reset of Debouncing'1' No Card or Inserted</td></tr>
<tr valign=top><td>sdhccarddet_inserted_dsync</td><td class="center">16</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Card insertion status flag. Read-only.<br/>Changing from 0 to 1 generates a Card Insertion interrupt in the Normal Interrupt Status register.<br/>Changing from 1 to 0 generates a Card Removal interrupt in the Normal Interrupt Status register.<br/>The Software Reset For All in the Software Reset register does not affect this bit.<br/>If a Card is removed while its power is on and its clock is oscillating, the controller clears SD Bus Power in the Power Control register and SD Clock Enable in the Clock control register. In addition the Host Driver should clear the controller using the Software Reset For All in Software register. The card detect is active regardless of the SD Bus Power.<br/>0: Reset or Debouncing or No Card.<br/>1: Card Inserted.</td></tr>
<tr valign=top><td>sdhcdmactrl_piobufrdena</td><td class="center">11</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status is used for non-DMA read transfers.This read only flag indicates that valid data exists in the host side buffer status. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when all the block data is ready in the buffer and generates the Buffer Read Ready Interrupt.'0' Read Disable'1' Read Enable</td></tr>
<tr valign=top><td>sdhcdmactrl_piobufwrena</td><td class="center">10</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status flag is used with write transfers via register writes (not DMA). Read-only.<br/>This flag indicates if space is available for writing data.<br/>0: do not write to the register port.<br/>1: data can be written to the buffer via the register port.<br/>A change from 1 to 0 indicates the buffer is full.<br/>A change from 0 to 1 occurs when top of block data can be written to the buffer and generates the Buffer Write Ready Interrupt.</td></tr>
<tr valign=top><td>sdhcdmactrl_rdxferactive</td><td class="center"> 9</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Completion of a read transfer flag. Read-only.<br/>This bit is set to 1 for either of the following conditions:<br/>*<br/>After the end bit of the read command, or<br/>*<br/>When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer.<br/>This bit is cleared to 0 for either of the following conditions:<br/>*<br/>When the last data block as specified by block length is transferred to the system, or<br/>*<br/>When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop At Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0.<br/>0: No valid data<br/>1: Transferring data</td></tr>
<tr valign=top><td>sdhcdmactrl_wrxferactive</td><td class="center"> 8</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the HC.<br/>This bit is set in either of the following cases:<br/>* After the end bit of the write command.<br/>* When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer.<br/>This bit is cleared in either of the following cases:<br/>* After getting the CRC status of the last data block as specified by the transfer count (Single<br/>or Multiple)<br/>* After getting a CRC status of any block where data transmission is about to be stopped by a Stop At Block Gap Request.<br/>During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop At Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy.'0' No valid data'1' Transferring data</td></tr>
<tr valign=top><td>sdhcsdctrl_retuningreq_dsync</td><td class="center"> 3</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Controller may request that the Host Driver executes the re-tuning sequence using this bit.<br/>Re-tune the I/O timing when the data window is shifted by temperature changes or to improve timing margins to receive correct data.<br/>0: Sampling clock is okay (it's fixed timing or well tuned).<br/>1: Re-tune the sampling clock.<br/>This bit is set = 0 when a command is issued by setting the Execute Tuning bit in the Host Control 2 register.<br/>When software writes this bit from a 0 to 1 and [Sampling Clock Select] = 1 (not fixed sampling), the controller triggers the re-tune event.<br/>Refer to Normal Interrupt registers for more detail.</td></tr>
<tr valign=top><td>sdhcdmactrl_datalineactive</td><td class="center"> 2</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>SD_DAT signal I/O activity:<br/>0: inactive.<br/>1: active.</td></tr>
<tr valign=top><td>presentstate_inhibitdat</td><td class="center"> 1</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Dual purpose status indicator:<br/>* SD_DAT I/O is active, or<br/>* Read transfer Active is set to 1. [ ]<br/>0: controller can issue the next SD command.<br/>Commands with busy signal belong to Command Inhibit (DAT) (ex. R1b, R5b type).<br/>When the status indicator changes from a 0 to 1, the Transfer Complete interrupt asserts.<br/>Note: The SD Host Driver can save registers in the range of 000-00Dh; for a suspend transaction this bit changes from 1 to 0.'0' Can issue command which uses the DAT line'1' Cannot issue command which uses the DATline</td></tr>
<tr valign=top><td>presentstate_inhibitcmd</td><td class="center"> 0</td><td class="tooltip">ro<span class="tooltiptext">Read-only</span></td><td class="hex">0x0</td><td>Controller State.<br/>0: The CMD line is not in use and the controller can issue a SD command using the CMD line.<br/>This bit is set immediately after the Command register (00Fh) is written. This bit is cleared when the command response is received.<br/>Even if the Command Inhibit (DAT) is set to 1, Commands using only the CMD line can be issued if this bit is 0.<br/>Changing from 1 to 0 generates a Command complete interrupt in the Normal Interrupt Status register. If the controller cannot issue the command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit remains a 1 and the Command Complete interrupt is not set.<br/>Status issuing Auto CMD12 is not read from this bit. Auto CMD12 and Auto CMD23 consist of two responses. In this case, this bit is not cleared by the response of CMD12 or CMD23 but cleared by the response of a read/write command. Status issuing Auto CMD12 is not read from this bit. So if a command is issued during Auto CMD12 operation, controller issues two commands: CMD12 and a command set by Command register.</td></tr>
</table><p id=foot class=footer></p>
</body>
</html>